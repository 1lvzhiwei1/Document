# 垃圾收集器

## Serial

==单线程==、==stop the world==

**HotSpot虚拟机运行在客户端模式下的默认新生代收集器，简单高效、额外内存消耗最小、最高的单线程收集效率**

**适用于运行在客户端模式下的虚拟机**

**新生代采用复制算法、老年代采用标记-整理算法**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210220141744190.png" alt="image-20210220141744190" style="zoom:80%;" />

## ParNew

==多线程==、==stop the world==

**控制参数、收集算法、stop the world、对象分配规则、回收策略等都和Serial完全一致**

**ParNew是激活CMS后的默认新生代收集器**

**JDK 9之后，ParNew合并入CMS，成为它专门处理新生代的组成部分**

![image-20210220142405543](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210220142405543.png)

## 概念解释

==并行==

**多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态**

==并发==

**垃圾收集器线程和用户线程之间的关系，说明同一时间垃圾收集器线程和用户线程都在运行；程序仍然能响应服务请求，但是由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响**

## Parallel Scavenge

==新生代==、==标记-复制算法==、==并行收集==、==多线程==

**目标达到可控制的吞吐量**

**吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)**

**控制吞吐量参数**

* -XX:MaxGCPauseMillis：最大垃圾收集停顿时间
* -XX:GCTimeRatio：设置吞吐量大小

**垃圾收集的自适应的调节策略**

* 通过参数-XX:+UseAdaptiveSizePolicy开启
* 虚拟机根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或者最大吞吐量

## Serial Old

==老年代==、==单线程==、==标记-整理算法==

**主要意义供客户端模式下的HotSpot虚拟机使用**

**如果在服务端模式下，可能有两种用途：**

* JDK 5以及之前的版本中与Parallel Scavenge搭配使用
* 作为CMS发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210220141744190.png" alt="image-20210220141744190" style="zoom:80%;" />

## Parallel Old

==老年代==、==并发收集==、==多线程==、==标记-整理算法==

**JDK 6开始提供**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210220145033581.png" alt="image-20210220145033581" style="zoom:90%;" />

## CMS

==并发收集==、==低停顿==、==标记-清除算法==

**以获取最短回收停顿时间为目标**

**适用于互联网网站上或者基于浏览器的B/S系统的服务器上的Java应用**

### 初始标记

==stop the world==

**标记一下GC Roots能直接关联到的对象，速度很快**

### 并发标记

**从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时长但不需要停顿用户线程**

### 重新标记

==stop the world==

**修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**

### 并发清除

**清理删除掉标记阶段判断的已经死亡的对象，不需要移动存货对象，所以也是并发的**

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210220150457034.png" alt="image-20210220150457034" style="zoom:85%;" />

### 缺点

* CMS收集器对处理器资源非常敏感：CMS默认启动的回收线程数是 (处理器核心+3)/4，当处理器核心不足4个的时候，CMS对用户程序的影响就可能变得很大
* CMS无法处理浮动垃圾，可能出现Concurrent Mode Failure进而导致另一次完全stop the world的Full GC产生
* CMS采用标记-清除算法，会产生大量空间碎片

## G1

**开创了面向局部收集的设计思路、基于Region的内存布局形式**

==G1把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间==

==Humongous区域：专门存储大对象(大小超过一个Region容量一半的对象)==

### 初始标记

==stop the world==

**仅仅标记一下GC Roots能直接关联到的对象，需要停顿、耗时很短、Minor GC时同步完成，所以实际上没有实际的停顿**

### 并发标记

**从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，耗时较长、并发执行**

**当对象图扫描完成后，还要重新处理SATB记录下的在并发时有引用变动的对象**

### 最终标记

==stop the world==

**对用户线程做一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录**

### 筛选回收

==stop the world==

**负责更新Region的统计数据，对各个Region的回收价值和成本进行排序是，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间** ==这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的==

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210220163451509.png" alt="image-20210220163451509" style="zoom:90%;" />